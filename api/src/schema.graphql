### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly

input BooleanFilter {
    equals: Boolean
    not: Boolean
}

type Collection {
    createdAt: DateTime!
    detail: String
    id: ID!
    isDeleted: Boolean!
    items(
        after: ID
        before: ID
        first: Int
        last: Int
        orderBy: CollectionItemsOrderByInput
        skip: Int
        where: CollectionItemsWhereInput
    ): [Item!]!
    name: String
    owner: User!
    section: Section!
    slug: String!
    updatedAt: DateTime!
}

input CollectionCreateManyWithoutCollectionsInput {
    connect: [CollectionWhereUniqueInput!]
    create: [CollectionCreateWithoutSectionInput!]
}

input CollectionCreateOneWithoutCollectionInput {
    connect: CollectionWhereUniqueInput
    create: CollectionCreateWithoutItemsInput
}

input CollectionCreateWithoutItemsInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    name: String
    owner: UserCreateOneWithoutOwnerInput!
    section: SectionCreateOneWithoutSectionInput!
    slug: String!
    updatedAt: DateTime
}

input CollectionCreateWithoutOwnerInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    items: ItemCreateManyWithoutItemsInput
    name: String
    section: SectionCreateOneWithoutSectionInput!
    slug: String!
    updatedAt: DateTime
}

input CollectionCreateWithoutSectionInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    items: ItemCreateManyWithoutItemsInput
    name: String
    owner: UserCreateOneWithoutOwnerInput!
    slug: String!
    updatedAt: DateTime
}

input CollectionFilter {
    every: CollectionWhereInput
    none: CollectionWhereInput
    some: CollectionWhereInput
}

input CollectionItemsOrderByInput {
    createdAt: OrderByArg
    position: OrderByArg
}

input CollectionItemsWhereInput {
    isDeleted: BooleanFilter
}

input CollectionScalarWhereInput {
    AND: [CollectionScalarWhereInput!]
    createdAt: DateTimeFilter
    detail: NullableStringFilter
    id: StringFilter
    isDeleted: BooleanFilter
    items: ItemFilter
    name: NullableStringFilter
    NOT: [CollectionScalarWhereInput!]
    OR: [CollectionScalarWhereInput!]
    slug: StringFilter
    updatedAt: DateTimeFilter
}

input CollectionUpdateInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    items: ItemUpdateManyWithoutCollectionInput
    name: String
    owner: UserUpdateOneRequiredWithoutCollectionsInput
    section: SectionUpdateOneRequiredWithoutCollectionsInput
    slug: String
    updatedAt: DateTime
}

input CollectionUpdateManyDataInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    name: String
    slug: String
    updatedAt: DateTime
}

input CollectionUpdateManyWithoutOwnerInput {
    connect: [CollectionWhereUniqueInput!]
    create: [CollectionCreateWithoutOwnerInput!]
    delete: [CollectionWhereUniqueInput!]
    deleteMany: [CollectionScalarWhereInput!]
    disconnect: [CollectionWhereUniqueInput!]
    set: [CollectionWhereUniqueInput!]
    update: [CollectionUpdateWithWhereUniqueWithoutOwnerInput!]
    updateMany: [CollectionUpdateManyWithWhereNestedInput!]
    upsert: [CollectionUpsertWithWhereUniqueWithoutOwnerInput!]
}

input CollectionUpdateManyWithoutSectionInput {
    connect: [CollectionWhereUniqueInput!]
    create: [CollectionCreateWithoutSectionInput!]
    delete: [CollectionWhereUniqueInput!]
    deleteMany: [CollectionScalarWhereInput!]
    disconnect: [CollectionWhereUniqueInput!]
    set: [CollectionWhereUniqueInput!]
    update: [CollectionUpdateWithWhereUniqueWithoutSectionInput!]
    updateMany: [CollectionUpdateManyWithWhereNestedInput!]
    upsert: [CollectionUpsertWithWhereUniqueWithoutSectionInput!]
}

input CollectionUpdateManyWithWhereNestedInput {
    data: CollectionUpdateManyDataInput!
    where: CollectionScalarWhereInput!
}

input CollectionUpdateOneWithoutItemsInput {
    connect: CollectionWhereUniqueInput
    create: CollectionCreateWithoutItemsInput
    delete: Boolean
    disconnect: Boolean
    update: CollectionUpdateWithoutItemsDataInput
    upsert: CollectionUpsertWithoutItemsInput
}

input CollectionUpdateWithoutItemsDataInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    name: String
    owner: UserUpdateOneRequiredWithoutCollectionsInput
    section: SectionUpdateOneRequiredWithoutCollectionsInput
    slug: String
    updatedAt: DateTime
}

input CollectionUpdateWithoutOwnerDataInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    items: ItemUpdateManyWithoutCollectionInput
    name: String
    section: SectionUpdateOneRequiredWithoutCollectionsInput
    slug: String
    updatedAt: DateTime
}

input CollectionUpdateWithoutSectionDataInput {
    createdAt: DateTime
    detail: String
    id: ID
    isDeleted: Boolean
    items: ItemUpdateManyWithoutCollectionInput
    name: String
    owner: UserUpdateOneRequiredWithoutCollectionsInput
    slug: String
    updatedAt: DateTime
}

input CollectionUpdateWithWhereUniqueWithoutOwnerInput {
    data: CollectionUpdateWithoutOwnerDataInput!
    where: CollectionWhereUniqueInput!
}

input CollectionUpdateWithWhereUniqueWithoutSectionInput {
    data: CollectionUpdateWithoutSectionDataInput!
    where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithoutItemsInput {
    create: CollectionCreateWithoutItemsInput!
    update: CollectionUpdateWithoutItemsDataInput!
}

input CollectionUpsertWithWhereUniqueWithoutOwnerInput {
    create: CollectionCreateWithoutOwnerInput!
    update: CollectionUpdateWithoutOwnerDataInput!
    where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithWhereUniqueWithoutSectionInput {
    create: CollectionCreateWithoutSectionInput!
    update: CollectionUpdateWithoutSectionDataInput!
    where: CollectionWhereUniqueInput!
}

input CollectionWhereInput {
    AND: [CollectionWhereInput!]
    createdAt: DateTimeFilter
    detail: NullableStringFilter
    id: StringFilter
    isDeleted: BooleanFilter
    items: ItemFilter
    name: NullableStringFilter
    NOT: [CollectionWhereInput!]
    OR: [CollectionWhereInput!]
    owner: UserWhereInput
    section: SectionWhereInput
    slug: StringFilter
    updatedAt: DateTimeFilter
}

input CollectionWhereUniqueInput {
    id: ID
    slug: String
}

scalar DateTime

input DateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: DateTime
    notIn: [DateTime!]
}

"""
Inbox user relative content
"""
type Inbox {
    """
    Non deleted items count in inbox
    """
    count: Int!
    id: String!
    items: [Item!]!
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: Int
    notIn: [Int!]
}

type Item {
    author: String
    comment: String
    createdAt: DateTime!
    description: String
    id: ID!
    imageUrl: String
    isDeleted: Boolean!
    meta: String
    position: Int!
    productUrl: String
    provider: String
    title: String!
    type: ItemType!
}

input ItemCreateManyWithoutInboxedItemsInput {
    connect: [ItemWhereUniqueInput!]
    create: [ItemCreateWithoutInboxOwnerInput!]
}

input ItemCreateManyWithoutItemsInput {
    connect: [ItemWhereUniqueInput!]
    create: [ItemCreateWithoutCollectionInput!]
}

input ItemCreateWithoutCollectionInput {
    author: String
    comment: String
    createdAt: DateTime
    description: String
    id: ID
    imageUrl: String
    inboxOwner: UserCreateOneWithoutInboxOwnerInput
    isDeleted: Boolean
    meta: String
    position: Int
    productUrl: String
    provider: String
    title: String!
    type: ItemType!
    updatedAt: DateTime
}

input ItemCreateWithoutInboxOwnerInput {
    author: String
    collection: CollectionCreateOneWithoutCollectionInput
    comment: String
    createdAt: DateTime
    description: String
    id: ID
    imageUrl: String
    isDeleted: Boolean
    meta: String
    position: Int
    productUrl: String
    provider: String
    title: String!
    type: ItemType!
    updatedAt: DateTime
}

input ItemFilter {
    every: ItemWhereInput
    none: ItemWhereInput
    some: ItemWhereInput
}

input ItemScalarWhereInput {
    AND: [ItemScalarWhereInput!]
    author: NullableStringFilter
    comment: NullableStringFilter
    createdAt: DateTimeFilter
    description: NullableStringFilter
    id: StringFilter
    imageUrl: NullableStringFilter
    isDeleted: BooleanFilter
    meta: NullableStringFilter
    NOT: [ItemScalarWhereInput!]
    OR: [ItemScalarWhereInput!]
    position: IntFilter
    productUrl: NullableStringFilter
    provider: NullableStringFilter
    title: StringFilter
    type: ItemType
    updatedAt: DateTimeFilter
}

enum ItemType {
    album
    article
    book
    movie
    people
    podcast
    repository
    video
    website
}

input ItemUpdateInput {
    author: String
    collection: CollectionUpdateOneWithoutItemsInput
    comment: String
    createdAt: DateTime
    description: String
    id: ID
    imageUrl: String
    inboxOwner: UserUpdateOneWithoutInboxedItemsInput
    isDeleted: Boolean
    meta: String
    position: Int
    productUrl: String
    provider: String
    title: String
    type: ItemType
    updatedAt: DateTime
}

input ItemUpdateManyDataInput {
    author: String
    comment: String
    createdAt: DateTime
    description: String
    id: ID
    imageUrl: String
    isDeleted: Boolean
    meta: String
    position: Int
    productUrl: String
    provider: String
    title: String
    type: ItemType
    updatedAt: DateTime
}

input ItemUpdateManyWithoutCollectionInput {
    connect: [ItemWhereUniqueInput!]
    create: [ItemCreateWithoutCollectionInput!]
    delete: [ItemWhereUniqueInput!]
    deleteMany: [ItemScalarWhereInput!]
    disconnect: [ItemWhereUniqueInput!]
    set: [ItemWhereUniqueInput!]
    update: [ItemUpdateWithWhereUniqueWithoutCollectionInput!]
    updateMany: [ItemUpdateManyWithWhereNestedInput!]
    upsert: [ItemUpsertWithWhereUniqueWithoutCollectionInput!]
}

input ItemUpdateManyWithoutInboxOwnerInput {
    connect: [ItemWhereUniqueInput!]
    create: [ItemCreateWithoutInboxOwnerInput!]
    delete: [ItemWhereUniqueInput!]
    deleteMany: [ItemScalarWhereInput!]
    disconnect: [ItemWhereUniqueInput!]
    set: [ItemWhereUniqueInput!]
    update: [ItemUpdateWithWhereUniqueWithoutInboxOwnerInput!]
    updateMany: [ItemUpdateManyWithWhereNestedInput!]
    upsert: [ItemUpsertWithWhereUniqueWithoutInboxOwnerInput!]
}

input ItemUpdateManyWithWhereNestedInput {
    data: ItemUpdateManyDataInput!
    where: ItemScalarWhereInput!
}

input ItemUpdateWithoutCollectionDataInput {
    author: String
    comment: String
    createdAt: DateTime
    description: String
    id: ID
    imageUrl: String
    inboxOwner: UserUpdateOneWithoutInboxedItemsInput
    isDeleted: Boolean
    meta: String
    position: Int
    productUrl: String
    provider: String
    title: String
    type: ItemType
    updatedAt: DateTime
}

input ItemUpdateWithoutInboxOwnerDataInput {
    author: String
    collection: CollectionUpdateOneWithoutItemsInput
    comment: String
    createdAt: DateTime
    description: String
    id: ID
    imageUrl: String
    isDeleted: Boolean
    meta: String
    position: Int
    productUrl: String
    provider: String
    title: String
    type: ItemType
    updatedAt: DateTime
}

input ItemUpdateWithWhereUniqueWithoutCollectionInput {
    data: ItemUpdateWithoutCollectionDataInput!
    where: ItemWhereUniqueInput!
}

input ItemUpdateWithWhereUniqueWithoutInboxOwnerInput {
    data: ItemUpdateWithoutInboxOwnerDataInput!
    where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutCollectionInput {
    create: ItemCreateWithoutCollectionInput!
    update: ItemUpdateWithoutCollectionDataInput!
    where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutInboxOwnerInput {
    create: ItemCreateWithoutInboxOwnerInput!
    update: ItemUpdateWithoutInboxOwnerDataInput!
    where: ItemWhereUniqueInput!
}

input ItemWhereInput {
    AND: [ItemWhereInput!]
    author: NullableStringFilter
    collection: CollectionWhereInput
    comment: NullableStringFilter
    createdAt: DateTimeFilter
    description: NullableStringFilter
    id: StringFilter
    imageUrl: NullableStringFilter
    inboxOwner: UserWhereInput
    isDeleted: BooleanFilter
    meta: NullableStringFilter
    NOT: [ItemWhereInput!]
    OR: [ItemWhereInput!]
    position: IntFilter
    productUrl: NullableStringFilter
    provider: NullableStringFilter
    title: StringFilter
    type: ItemType
    updatedAt: DateTimeFilter
}

input ItemWhereUniqueInput {
    id: ID
}

type Mutation {
    """
    Mutation changing the position of an item from his $oldIndex to the $newIndex.
                It takes *indexes* (not position) and return changed items with new position.
    """
    changeItemPosition(
        collectionId: ID!
        newIndex: Int!
        oldIndex: Int!
    ): [Item!]!
    createEmptyCollection(sectionId: ID!): Collection!
    createEmptySection: Section!
    createItemFromSearch(
        collectionId: String
        id: String!
        inbox: Boolean
        kind: String!
    ): Item!
    createItemFromUrl(collectionId: String, inbox: Boolean, url: String!): Item!
    createNewUser(
        authUserId: String!
        firstname: String!
        pictureUrl: String!
        slug: String!
    ): User!
    createOneUser(data: UserCreateInput!): User!
    updateOneCollection(
        data: CollectionUpdateInput!
        where: CollectionWhereUniqueInput!
    ): Collection
    updateOneItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
    updateOneSection(
        data: SectionUpdateInput!
        where: SectionWhereUniqueInput!
    ): Section
    updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: String
    notIn: [String!]
    startsWith: String
}

enum OrderByArg {
    asc
    desc
}

type Query {
    collection(where: CollectionWhereUniqueInput!): Collection
    collections(
        after: ID
        before: ID
        first: Int
        last: Int
        orderBy: QueryCollectionsOrderByInput
        skip: Int
        where: QueryCollectionsWhereInput
    ): [Collection!]!

    """
    Inbox user relative content
    """
    inbox: Inbox
    items(
        after: ID
        before: ID
        first: Int
        last: Int
        orderBy: QueryItemsOrderByInput
        skip: Int
        where: QueryItemsWhereInput
    ): [Item!]!
    search(kind: String!, q: String!): [SearchItem!]!
    section(where: SectionWhereUniqueInput!): Section
    sections(
        after: ID
        before: ID
        first: Int
        last: Int
        orderBy: QuerySectionsOrderByInput
        skip: Int
        where: QuerySectionsWhereInput
    ): [Section!]!
    user(where: UserWhereUniqueInput!): User
}

input QueryCollectionsOrderByInput {
    createdAt: OrderByArg
}

input QueryCollectionsWhereInput {
    isDeleted: BooleanFilter
    owner: UserWhereInput
    section: SectionWhereInput
}

input QueryItemsOrderByInput {
    position: OrderByArg
}

input QueryItemsWhereInput {
    collection: CollectionWhereInput
    isDeleted: BooleanFilter
}

input QuerySectionsOrderByInput {
    createdAt: OrderByArg
}

input QuerySectionsWhereInput {
    index: IntFilter
    isDeleted: BooleanFilter
    owner: UserWhereInput
}

type SearchItem {
    author: String
    id: String!
    title: String!
    type: String!
}

type Section {
    collections(
        after: ID
        before: ID
        first: Int
        last: Int
        orderBy: SectionCollectionsOrderByInput
        skip: Int
        where: SectionCollectionsWhereInput
    ): [Collection!]!
    createdAt: DateTime!
    id: ID!
    index: Int!
    isExpanded: Boolean!
    name: String
    slug: String!
}

input SectionCollectionsOrderByInput {
    createdAt: OrderByArg
    updatedAt: OrderByArg
}

input SectionCollectionsWhereInput {
    isDeleted: BooleanFilter
}

input SectionCreateManyWithoutSectionsInput {
    connect: [SectionWhereUniqueInput!]
    create: [SectionCreateWithoutOwnerInput!]
}

input SectionCreateOneWithoutSectionInput {
    connect: SectionWhereUniqueInput
    create: SectionCreateWithoutCollectionsInput
}

input SectionCreateWithoutCollectionsInput {
    createdAt: DateTime
    id: ID
    index: Int
    isDeleted: Boolean
    isExpanded: Boolean
    name: String
    owner: UserCreateOneWithoutOwnerInput!
    slug: String!
    updatedAt: DateTime
}

input SectionCreateWithoutOwnerInput {
    collections: CollectionCreateManyWithoutCollectionsInput
    createdAt: DateTime
    id: ID
    index: Int
    isDeleted: Boolean
    isExpanded: Boolean
    name: String
    slug: String!
    updatedAt: DateTime
}

input SectionFilter {
    every: SectionWhereInput
    none: SectionWhereInput
    some: SectionWhereInput
}

input SectionScalarWhereInput {
    AND: [SectionScalarWhereInput!]
    collections: CollectionFilter
    createdAt: DateTimeFilter
    id: StringFilter
    index: IntFilter
    isDeleted: BooleanFilter
    isExpanded: BooleanFilter
    name: NullableStringFilter
    NOT: [SectionScalarWhereInput!]
    OR: [SectionScalarWhereInput!]
    slug: StringFilter
    updatedAt: DateTimeFilter
}

input SectionUpdateInput {
    collections: CollectionUpdateManyWithoutSectionInput
    createdAt: DateTime
    id: ID
    index: Int
    isDeleted: Boolean
    isExpanded: Boolean
    name: String
    owner: UserUpdateOneRequiredWithoutSectionsInput
    slug: String
    updatedAt: DateTime
}

input SectionUpdateManyDataInput {
    createdAt: DateTime
    id: ID
    index: Int
    isDeleted: Boolean
    isExpanded: Boolean
    name: String
    slug: String
    updatedAt: DateTime
}

input SectionUpdateManyWithoutOwnerInput {
    connect: [SectionWhereUniqueInput!]
    create: [SectionCreateWithoutOwnerInput!]
    delete: [SectionWhereUniqueInput!]
    deleteMany: [SectionScalarWhereInput!]
    disconnect: [SectionWhereUniqueInput!]
    set: [SectionWhereUniqueInput!]
    update: [SectionUpdateWithWhereUniqueWithoutOwnerInput!]
    updateMany: [SectionUpdateManyWithWhereNestedInput!]
    upsert: [SectionUpsertWithWhereUniqueWithoutOwnerInput!]
}

input SectionUpdateManyWithWhereNestedInput {
    data: SectionUpdateManyDataInput!
    where: SectionScalarWhereInput!
}

input SectionUpdateOneRequiredWithoutCollectionsInput {
    connect: SectionWhereUniqueInput
    create: SectionCreateWithoutCollectionsInput
    update: SectionUpdateWithoutCollectionsDataInput
    upsert: SectionUpsertWithoutCollectionsInput
}

input SectionUpdateWithoutCollectionsDataInput {
    createdAt: DateTime
    id: ID
    index: Int
    isDeleted: Boolean
    isExpanded: Boolean
    name: String
    owner: UserUpdateOneRequiredWithoutSectionsInput
    slug: String
    updatedAt: DateTime
}

input SectionUpdateWithoutOwnerDataInput {
    collections: CollectionUpdateManyWithoutSectionInput
    createdAt: DateTime
    id: ID
    index: Int
    isDeleted: Boolean
    isExpanded: Boolean
    name: String
    slug: String
    updatedAt: DateTime
}

input SectionUpdateWithWhereUniqueWithoutOwnerInput {
    data: SectionUpdateWithoutOwnerDataInput!
    where: SectionWhereUniqueInput!
}

input SectionUpsertWithoutCollectionsInput {
    create: SectionCreateWithoutCollectionsInput!
    update: SectionUpdateWithoutCollectionsDataInput!
}

input SectionUpsertWithWhereUniqueWithoutOwnerInput {
    create: SectionCreateWithoutOwnerInput!
    update: SectionUpdateWithoutOwnerDataInput!
    where: SectionWhereUniqueInput!
}

input SectionWhereInput {
    AND: [SectionWhereInput!]
    collections: CollectionFilter
    createdAt: DateTimeFilter
    id: StringFilter
    index: IntFilter
    isDeleted: BooleanFilter
    isExpanded: BooleanFilter
    name: NullableStringFilter
    NOT: [SectionWhereInput!]
    OR: [SectionWhereInput!]
    owner: UserWhereInput
    slug: StringFilter
    updatedAt: DateTimeFilter
}

input SectionWhereUniqueInput {
    id: ID
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: String
    notIn: [String!]
    startsWith: String
}

type User {
    authUserId: String
    biography: String
    firstname: String!
    github: String
    id: ID!
    label: String
    linkedin: String
    mail: String
    pictureUrl: String!
    sections(
        after: ID
        before: ID
        first: Int
        last: Int
        skip: Int
    ): [Section!]!
    slug: String!
    website: String
    youtube: String
}

input UserCreateInput {
    authUserId: String
    biography: String
    collections: CollectionCreateManyWithoutCollectionsInput
    createdAt: DateTime
    firstname: String!
    github: String
    id: ID
    inboxedItems: ItemCreateManyWithoutInboxedItemsInput
    label: String
    linkedin: String
    mail: String
    pictureUrl: String!
    sections: SectionCreateManyWithoutSectionsInput
    slug: String!
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserCreateOneWithoutInboxOwnerInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutInboxedItemsInput
}

input UserCreateOneWithoutOwnerInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutCollectionsInput
}

input UserCreateWithoutCollectionsInput {
    authUserId: String
    biography: String
    createdAt: DateTime
    firstname: String!
    github: String
    id: ID
    inboxedItems: ItemCreateManyWithoutInboxedItemsInput
    label: String
    linkedin: String
    mail: String
    pictureUrl: String!
    sections: SectionCreateManyWithoutSectionsInput
    slug: String!
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserCreateWithoutInboxedItemsInput {
    authUserId: String
    biography: String
    collections: CollectionCreateManyWithoutCollectionsInput
    createdAt: DateTime
    firstname: String!
    github: String
    id: ID
    label: String
    linkedin: String
    mail: String
    pictureUrl: String!
    sections: SectionCreateManyWithoutSectionsInput
    slug: String!
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserCreateWithoutSectionsInput {
    authUserId: String
    biography: String
    collections: CollectionCreateManyWithoutCollectionsInput
    createdAt: DateTime
    firstname: String!
    github: String
    id: ID
    inboxedItems: ItemCreateManyWithoutInboxedItemsInput
    label: String
    linkedin: String
    mail: String
    pictureUrl: String!
    slug: String!
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserUpdateInput {
    authUserId: String
    biography: String
    collections: CollectionUpdateManyWithoutOwnerInput
    createdAt: DateTime
    firstname: String
    github: String
    id: ID
    inboxedItems: ItemUpdateManyWithoutInboxOwnerInput
    label: String
    linkedin: String
    mail: String
    pictureUrl: String
    sections: SectionUpdateManyWithoutOwnerInput
    slug: String
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserUpdateOneRequiredWithoutCollectionsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutCollectionsInput
    update: UserUpdateWithoutCollectionsDataInput
    upsert: UserUpsertWithoutCollectionsInput
}

input UserUpdateOneRequiredWithoutSectionsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutSectionsInput
    update: UserUpdateWithoutSectionsDataInput
    upsert: UserUpsertWithoutSectionsInput
}

input UserUpdateOneWithoutInboxedItemsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutInboxedItemsInput
    delete: Boolean
    disconnect: Boolean
    update: UserUpdateWithoutInboxedItemsDataInput
    upsert: UserUpsertWithoutInboxedItemsInput
}

input UserUpdateWithoutCollectionsDataInput {
    authUserId: String
    biography: String
    createdAt: DateTime
    firstname: String
    github: String
    id: ID
    inboxedItems: ItemUpdateManyWithoutInboxOwnerInput
    label: String
    linkedin: String
    mail: String
    pictureUrl: String
    sections: SectionUpdateManyWithoutOwnerInput
    slug: String
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserUpdateWithoutInboxedItemsDataInput {
    authUserId: String
    biography: String
    collections: CollectionUpdateManyWithoutOwnerInput
    createdAt: DateTime
    firstname: String
    github: String
    id: ID
    label: String
    linkedin: String
    mail: String
    pictureUrl: String
    sections: SectionUpdateManyWithoutOwnerInput
    slug: String
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserUpdateWithoutSectionsDataInput {
    authUserId: String
    biography: String
    collections: CollectionUpdateManyWithoutOwnerInput
    createdAt: DateTime
    firstname: String
    github: String
    id: ID
    inboxedItems: ItemUpdateManyWithoutInboxOwnerInput
    label: String
    linkedin: String
    mail: String
    pictureUrl: String
    slug: String
    updatedAt: DateTime
    website: String
    youtube: String
}

input UserUpsertWithoutCollectionsInput {
    create: UserCreateWithoutCollectionsInput!
    update: UserUpdateWithoutCollectionsDataInput!
}

input UserUpsertWithoutInboxedItemsInput {
    create: UserCreateWithoutInboxedItemsInput!
    update: UserUpdateWithoutInboxedItemsDataInput!
}

input UserUpsertWithoutSectionsInput {
    create: UserCreateWithoutSectionsInput!
    update: UserUpdateWithoutSectionsDataInput!
}

input UserWhereInput {
    AND: [UserWhereInput!]
    authUserId: NullableStringFilter
    biography: NullableStringFilter
    collections: CollectionFilter
    createdAt: DateTimeFilter
    firstname: StringFilter
    github: NullableStringFilter
    id: StringFilter
    inboxedItems: ItemFilter
    label: NullableStringFilter
    linkedin: NullableStringFilter
    mail: NullableStringFilter
    NOT: [UserWhereInput!]
    OR: [UserWhereInput!]
    pictureUrl: StringFilter
    sections: SectionFilter
    slug: StringFilter
    updatedAt: DateTimeFilter
    website: NullableStringFilter
    youtube: NullableStringFilter
}

input UserWhereUniqueInput {
    authUserId: String
    id: ID
    slug: String
}
